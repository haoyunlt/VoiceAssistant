# VoiceHelper ÂäüËÉΩËøÅÁßªËÆ°Âàí

> **ËøÅÁßªÊù•Ê∫ê**: https://github.com/haoyunlt/voicehelper (v0.9.2)
> **ÁõÆÊ†áÈ°πÁõÆ**: VoiceAssistant
> **ËøÅÁßªÂäüËÉΩ**: 10 È°πÂÖ≥ÈîÆÂäüËÉΩ
> **È¢ÑËÆ°Â∑•‰ΩúÈáè**: 35-45 ‰∫∫Â§©
> **ËÆ°ÂàíÂë®Êúü**: 8-10 Âë®

---

## üìä ÊâßË°åÊëòË¶Å

### ËøÅÁßªËÉåÊôØ

VoiceHelper È°πÁõÆÊòØ‰∏Ä‰∏™ÊàêÁÜüÁöÑ AI ËØ≠Èü≥Âä©ÊâãÈ°πÁõÆÔºåÂ∑≤ÂÆûÁé∞Â§öÈ°πÁîü‰∫ßÁ∫ßÂäüËÉΩ„ÄÇÈÄöËøáÂØπÊØîÂàÜÊûêÔºåÊàë‰ª¨ÂèëÁé∞ÂΩìÂâç VoiceAssistant È°πÁõÆÂú®‰ª•‰∏ã 10 ‰∏™ÂÖ≥ÈîÆÂäüËÉΩ‰∏äËêΩÂêé‰∫é VoiceHelperÔºåÈúÄË¶Å‰ºòÂÖàËøÅÁßª„ÄÇ

### ÂÖ≥ÈîÆÂèëÁé∞

| Áª¥Â∫¶           | VoiceHelper   | VoiceAssistant ÂΩìÂâç | Â∑ÆË∑ùËØÑ‰º∞  |
| -------------- | ------------- | ------------------- | --------- |
| **ÂäüËÉΩÂÆåÊï¥Â∫¶** | 90%           | 45%                 | üî¥ È´òÂ∑ÆË∑ù |
| **Áîü‰∫ßÂ∞±Áª™Â∫¶** | Áîü‰∫ßÁ∫ß        | ÂºÄÂèë‰∏≠              | üî¥ È´òÂ∑ÆË∑ù |
| **ÂÖ≥ÈîÆÂäüËÉΩ**   | 10 È°πÂ∑≤ÂÆûÁé∞   | 0 È°πÂ∑≤ÂÆûÁé∞          | üî¥ È´òÂ∑ÆË∑ù |
| **Êû∂ÊûÑÂ§çÊùÇÂ∫¶** | ÁÆÄÊ¥Å (5 ÊúçÂä°) | Â§çÊùÇ (15 ÊúçÂä°)      | ‚ö†Ô∏è ÈúÄÊùÉË°° |

### ËøÅÁßª‰ª∑ÂÄº

- **Áº©Áü≠ÂºÄÂèëÂë®Êúü**: ÈÅøÂÖçÈáçÂ§çÈÄ†ËΩÆÂ≠êÔºåËäÇÁúÅ 4-6 Âë®ÂºÄÂèëÊó∂Èó¥
- **Èôç‰ΩéÊäÄÊúØÈ£éÈô©**: ÈááÁî®Â∑≤È™åËØÅÁöÑÁîü‰∫ßÁ∫ßÂÆûÁé∞
- **ÊèêÂçáÁ´û‰∫âÂäõ**: Âø´ÈÄüËææÂà∞Ë°å‰∏öÈ¢ÜÂÖàÊ∞¥Âπ≥
- **ËäÇÁ∫¶ÊàêÊú¨**: È¢ÑËÆ°ËäÇÁúÅ $40k-$60k ÂºÄÂèëÊàêÊú¨

---

## üéØ ËøÅÁßªÂäüËÉΩÊ∏ÖÂçï

### ‰ºòÂÖàÁ∫ßÂàÜÁ∫ß

```
P0 (Ê†∏ÂøÉÈòªÂ°û): ÂøÖÈ°ªÁ´ãÂç≥ËøÅÁßªÔºåÈòªÂ°û MVP
P1 (ÈáçË¶ÅÂ¢ûÂº∫): ÊòæËëóÊèêÂçáÁî®Êà∑‰ΩìÈ™åÂíåÁ≥ªÁªüËÉΩÂäõ
P2 (Èî¶‰∏äÊ∑ªËä±): È´òÁ∫ßÁâπÊÄßÔºåÂèØÂª∂Âêé
```

### 10 È°πÂæÖËøÅÁßªÂäüËÉΩ

| #   | ÂäüËÉΩÂêçÁß∞                                | ‰ºòÂÖàÁ∫ß | ÊâÄÂ±ûÊúçÂä°             | Â∑•‰ΩúÈáè | ‰æùËµñÂÖ≥Á≥ª          | Sprint   |
| --- | --------------------------------------- | ------ | -------------------- | ------ | ----------------- | -------- |
| 1   | [ÊµÅÂºè ASR ËØÜÂà´](#1-ÊµÅÂºè-asr-ËØÜÂà´)       | P0     | Voice Engine         | 4-5 Â§© | WebSocket, VAD    | Sprint 1 |
| 2   | [ÈïøÊúüËÆ∞ÂøÜË°∞Âáè](#2-ÈïøÊúüËÆ∞ÂøÜË°∞Âáè)         | P0     | Agent Engine         | 3-4 Â§© | Milvus, Embedding | Sprint 1 |
| 3   | [Redis ‰ªªÂä°ÊåÅ‰πÖÂåñ](#3-redis-‰ªªÂä°ÊåÅ‰πÖÂåñ) | P0     | Agent Engine         | 2-3 Â§© | Redis             | Sprint 2 |
| 4   | [ÂàÜÂ∏ÉÂºèÈôêÊµÅÂô®](#4-ÂàÜÂ∏ÉÂºèÈôêÊµÅÂô®)         | P1     | API Gateway          | 2-3 Â§© | Redis             | Sprint 2 |
| 5   | [GLM-4 Ê®°ÂûãÊîØÊåÅ](#5-glm-4-Ê®°ÂûãÊîØÊåÅ)     | P1     | Model Router         | 2 Â§©   | Êô∫Ë∞± AI API       | Sprint 3 |
| 6   | [ÊñáÊ°£ÁâàÊú¨ÁÆ°ÁêÜ](#6-ÊñáÊ°£ÁâàÊú¨ÁÆ°ÁêÜ)         | P1     | Knowledge Service    | 3-4 Â§© | PostgreSQL        | Sprint 3 |
| 7   | [ÁóÖÊØíÊâ´Êèè (ClamAV)](#7-ÁóÖÊØíÊâ´Êèè-clamav) | P1     | Knowledge Service    | 2-3 Â§© | ClamAV            | Sprint 4 |
| 8   | [Push ÈÄöÁü•](#8-push-ÈÄöÁü•)               | P2     | Notification Service | 3-4 Â§© | FCM, APNs         | Sprint 4 |
| 9   | [ÊÉÖÊÑüËØÜÂà´](#9-ÊÉÖÊÑüËØÜÂà´)                 | P2     | Voice Engine         | 3-4 Â§© | ÊÉÖÊÑüÊ®°Âûã          | Sprint 5 |
| 10  | [Consul ÊúçÂä°ÂèëÁé∞](#10-consul-ÊúçÂä°ÂèëÁé∞)  | P1     | ÊâÄÊúâ Go ÊúçÂä°         | 4-5 Â§© | Consul            | Sprint 2 |

**ÊÄªËÆ°Â∑•‰ΩúÈáè**: 35-45 ‰∫∫Â§© (Á∫¶ 7-9 Âë® @ 5 ‰∫∫Âõ¢Èòü)

---

## üìã ËØ¶ÁªÜËøÅÁßªÊñπÊ°à

### 1. ÊµÅÂºè ASR ËØÜÂà´

#### ÂΩìÂâçÁä∂ÊÄÅ

- ‚ùå ‰ªÖÊîØÊåÅÊâπÈáèËØÜÂà´
- ‚ùå Áî®Êà∑‰ΩìÈ™åÂ∑ÆÔºåÂª∂ËøüÈ´ò
- ‚ùå Êó†Ê≥ïÂÆûÊó∂ÂØπËØù

#### VoiceHelper ÂÆûÁé∞‰∫ÆÁÇπ

- ‚úÖ WebSocket ÂÆûÊó∂ÊµÅÂºè‰º†Ëæì
- ‚úÖ Silero VAD Á´ØÁÇπÊ£ÄÊµã
- ‚úÖ Â¢ûÈáèËØÜÂà´ + ÊúÄÁªàËØÜÂà´ÂèåÊ®°Âºè
- ‚úÖ ÂÆåÂñÑÁöÑÈîôËØØÂ§ÑÁêÜÂíåÈáçËøûÊú∫Âà∂

#### ËøÅÁßªËÆ°Âàí

**ÊäÄÊúØÊñπÊ°à**:

```python
# algo/voice-engine/app/routers/asr.py

from fastapi import WebSocket, WebSocketDisconnect
from app.services.streaming_asr_service import StreamingASRService
import asyncio

@router.websocket("/ws/asr/stream")
async def websocket_asr_stream(websocket: WebSocket):
    """WebSocket ÊµÅÂºè ASR (ÂèÇËÄÉ voicehelper)"""

    await websocket.accept()

    try:
        # 1. Êé•Êî∂ÈÖçÁΩÆ
        config_msg = await websocket.receive_json()

        model_size = config_msg.get("model_size", "base")
        language = config_msg.get("language", "zh")
        vad_enabled = config_msg.get("vad_enabled", True)

        # 2. ÂàùÂßãÂåñÊµÅÂºè ASR ÊúçÂä°
        streaming_asr = StreamingASRService(
            model_size=model_size,
            language=language,
            chunk_duration_ms=300,  # 300ms chunks
            vad_enabled=vad_enabled
        )

        # 3. Èü≥È¢ëÁîüÊàêÂô®
        async def audio_generator():
            """‰ªé WebSocket Êé•Êî∂Èü≥È¢ëÊµÅ"""
            while True:
                try:
                    message = await websocket.receive()

                    if "bytes" in message:
                        yield message["bytes"]

                    elif "text" in message:
                        cmd = json.loads(message["text"])
                        if cmd.get("type") == "end_stream":
                            break

                except WebSocketDisconnect:
                    break

        # 4. Â§ÑÁêÜÊµÅÂºèËØÜÂà´
        async for result in streaming_asr.process_stream(audio_generator()):
            await websocket.send_json(result)

    except WebSocketDisconnect:
        logger.info("Client disconnected")

    except Exception as e:
        logger.error(f"Streaming ASR error: {e}")
        await websocket.send_json({
            "type": "error",
            "error": str(e)
        })

    finally:
        await websocket.close()
```

**Ê†∏ÂøÉÊúçÂä°Á±ª**:

```python
# algo/voice-engine/app/services/streaming_asr_service.py

import webrtcvad
from faster_whisper import WhisperModel
import numpy as np
from typing import AsyncIterator
import time

class StreamingASRService:
    """ÊµÅÂºè ASR ÊúçÂä° (ÂèÇËÄÉ voicehelper ÂÆûÁé∞)"""

    def __init__(
        self,
        model_size: str = "base",
        language: str = "zh",
        chunk_duration_ms: int = 300,
        vad_enabled: bool = True,
        vad_mode: int = 3  # 0-3, 3 ÊúÄ‰∏•Ê†º
    ):
        # Whisper Ê®°Âûã
        self.model = WhisperModel(
            model_size,
            device="cuda" if torch.cuda.is_available() else "cpu",
            compute_type="int8"
        )
        self.language = language

        # VAD (Á´ØÁÇπÊ£ÄÊµã)
        self.vad_enabled = vad_enabled
        if vad_enabled:
            self.vad = webrtcvad.Vad(vad_mode)

        # Èü≥È¢ëÂèÇÊï∞
        self.chunk_duration_ms = chunk_duration_ms
        self.sample_rate = 16000
        self.chunk_size = int(self.sample_rate * chunk_duration_ms / 1000)

        # Áä∂ÊÄÅÁÆ°ÁêÜ
        self.audio_buffer = bytearray()
        self.speech_buffer = bytearray()
        self.is_speaking = False
        self.silence_duration = 0
        self.max_silence_duration_ms = 1500  # 1.5 ÁßíÈùôÈü≥Ëß¶ÂèëËØÜÂà´

    async def process_stream(
        self,
        audio_stream: AsyncIterator[bytes]
    ) -> AsyncIterator[dict]:
        """Â§ÑÁêÜÈü≥È¢ëÊµÅÔºåËøîÂõûËØÜÂà´ÁªìÊûúÊµÅ"""

        # ‰ºöËØùÂºÄÂßã
        yield {
            "type": "session_start",
            "sample_rate": self.sample_rate,
            "chunk_duration_ms": self.chunk_duration_ms,
            "vad_enabled": self.vad_enabled,
            "timestamp": time.time()
        }

        async for audio_chunk in audio_stream:
            # Ê∑ªÂä†Âà∞ÁºìÂÜ≤Âå∫
            self.audio_buffer.extend(audio_chunk)

            # Â§ÑÁêÜÂÆåÊï¥ÁöÑ chunk
            while len(self.audio_buffer) >= self.chunk_size * 2:  # 16-bit = 2 bytes
                chunk = bytes(self.audio_buffer[:self.chunk_size * 2])
                self.audio_buffer = self.audio_buffer[self.chunk_size * 2:]

                # VAD Ê£ÄÊµã
                is_speech = self._detect_speech(chunk) if self.vad_enabled else True

                if is_speech:
                    # Ê£ÄÊµãÂà∞ËØ≠Èü≥
                    if not self.is_speaking:
                        # ËØ≠Èü≥ÂºÄÂßã
                        self.is_speaking = True
                        self.speech_buffer = bytearray()

                        yield {
                            "type": "speech_start",
                            "timestamp": time.time()
                        }

                    # Á¥ØÁßØËØ≠Èü≥Êï∞ÊçÆ
                    self.speech_buffer.extend(chunk)
                    self.silence_duration = 0

                    # Â¢ûÈáèËØÜÂà´ (ÊØè 3 Áßí)
                    if len(self.speech_buffer) >= self.sample_rate * 2 * 3:
                        partial_text = await self._recognize_partial(self.speech_buffer)

                        yield {
                            "type": "partial_result",
                            "text": partial_text,
                            "is_final": False,
                            "confidence": 0.0,  # Â¢ûÈáèËØÜÂà´Êó†ÁΩÆ‰ø°Â∫¶
                            "timestamp": time.time()
                        }

                else:
                    # ÈùôÈü≥
                    if self.is_speaking:
                        self.silence_duration += self.chunk_duration_ms
                        self.speech_buffer.extend(chunk)  # ‰øùÁïôÈùôÈü≥‰ª•‰øùÊåÅËøûË¥ØÊÄß

                        # ÈùôÈü≥Ë∂ÖËøáÈòàÂÄºÔºåËß¶ÂèëÊúÄÁªàËØÜÂà´
                        if self.silence_duration >= self.max_silence_duration_ms:
                            final_text, confidence = await self._recognize_final(self.speech_buffer)

                            yield {
                                "type": "final_result",
                                "text": final_text,
                                "is_final": True,
                                "confidence": confidence,
                                "duration_ms": len(self.speech_buffer) / self.sample_rate / 2 * 1000,
                                "timestamp": time.time()
                            }

                            # ÈáçÁΩÆÁä∂ÊÄÅ
                            self.is_speaking = False
                            self.speech_buffer = bytearray()
                            self.silence_duration = 0

                            yield {
                                "type": "speech_end",
                                "timestamp": time.time()
                            }

        # ÊµÅÁªìÊùüÔºåÂ§ÑÁêÜÂâ©‰ΩôÊï∞ÊçÆ
        if self.is_speaking and len(self.speech_buffer) > 0:
            final_text, confidence = await self._recognize_final(self.speech_buffer)

            yield {
                "type": "final_result",
                "text": final_text,
                "is_final": True,
                "confidence": confidence,
                "timestamp": time.time()
            }

        yield {
            "type": "session_end",
            "timestamp": time.time()
        }

    def _detect_speech(self, audio_chunk: bytes) -> bool:
        """VAD Ê£ÄÊµãÊòØÂê¶‰∏∫ËØ≠Èü≥"""
        try:
            return self.vad.is_speech(audio_chunk, self.sample_rate)
        except Exception as e:
            logger.warning(f"VAD detection failed: {e}")
            return True  # Â§±Ë¥•Êó∂ÈªòËÆ§‰∏∫ËØ≠Èü≥

    async def _recognize_partial(self, audio_data: bytes) -> str:
        """Â¢ûÈáèËØÜÂà´ (Âø´ÈÄüÔºåÂáÜÁ°ÆÁéáËæÉ‰Ωé)"""
        audio_array = self._bytes_to_float32(audio_data)

        segments, _ = self.model.transcribe(
            audio_array,
            language=self.language,
            beam_size=1,  # Âø´ÈÄüÊ®°Âºè
            best_of=1,
            temperature=0.0,
            vad_filter=False
        )

        text = " ".join([seg.text for seg in segments])
        return text.strip()

    async def _recognize_final(self, audio_data: bytes) -> tuple[str, float]:
        """ÊúÄÁªàËØÜÂà´ (ÂÆåÊï¥ÂáÜÁ°ÆÁéá)"""
        audio_array = self._bytes_to_float32(audio_data)

        segments, info = self.model.transcribe(
            audio_array,
            language=self.language,
            beam_size=5,  # È´òÂáÜÁ°ÆÁéá
            best_of=5,
            temperature=0.0,
            vad_filter=True,
            condition_on_previous_text=True
        )

        text_segments = list(segments)
        text = " ".join([seg.text for seg in text_segments])

        # ËÆ°ÁÆóÂπ≥ÂùáÁΩÆ‰ø°Â∫¶
        avg_confidence = np.mean([seg.avg_logprob for seg in text_segments]) if text_segments else 0.0

        return text.strip(), float(avg_confidence)

    def _bytes_to_float32(self, audio_bytes: bytes) -> np.ndarray:
        """Â≠óËäÇËΩ¨Èü≥È¢ëÊï∞ÁªÑ"""
        audio_array = np.frombuffer(audio_bytes, dtype=np.int16)
        return audio_array.astype(np.float32) / 32768.0
```

**ÂâçÁ´ØÈõÜÊàê**:

```typescript
// platforms/web/components/StreamingASRClient.tsx

class StreamingASRClient {
  private ws: WebSocket | null = null;
  private mediaRecorder: MediaRecorder | null = null;
  private audioContext: AudioContext | null = null;

  constructor(
    private wsUrl: string,
    private config: {
      model_size: string;
      language: string;
      vad_enabled: boolean;
    },
    private callbacks: {
      onSessionStart?: (data: any) => void;
      onSpeechStart?: (data: any) => void;
      onPartialResult?: (data: any) => void;
      onFinalResult?: (data: any) => void;
      onSpeechEnd?: (data: any) => void;
      onError?: (error: string) => void;
    }
  ) {}

  async start() {
    // 1. Âª∫Á´ã WebSocket ËøûÊé•
    this.ws = new WebSocket(this.wsUrl);

    this.ws.onopen = () => {
      // ÂèëÈÄÅÈÖçÁΩÆ
      this.ws!.send(JSON.stringify(this.config));

      // ÂºÄÂßãÂΩïÈü≥
      this.startRecording();
    };

    this.ws.onmessage = (event) => {
      const result = JSON.parse(event.data);

      switch (result.type) {
        case 'session_start':
          this.callbacks.onSessionStart?.(result);
          break;
        case 'speech_start':
          this.callbacks.onSpeechStart?.(result);
          break;
        case 'partial_result':
          this.callbacks.onPartialResult?.(result);
          break;
        case 'final_result':
          this.callbacks.onFinalResult?.(result);
          break;
        case 'speech_end':
          this.callbacks.onSpeechEnd?.(result);
          break;
        case 'error':
          this.callbacks.onError?.(result.error);
          break;
      }
    };

    this.ws.onerror = (error) => {
      this.callbacks.onError?.('WebSocket error');
    };
  }

  private async startRecording() {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
      },
    });

    // ‰ΩøÁî® AudioContext Â§ÑÁêÜÈü≥È¢ë
    this.audioContext = new AudioContext({ sampleRate: 16000 });
    const source = this.audioContext.createMediaStreamSource(stream);
    const processor = this.audioContext.createScriptProcessor(4096, 1, 1);

    processor.onaudioprocess = (e) => {
      const inputData = e.inputBuffer.getChannelData(0);

      // ËΩ¨Êç¢‰∏∫ Int16
      const pcmData = new Int16Array(inputData.length);
      for (let i = 0; i < inputData.length; i++) {
        pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
      }

      // ÂèëÈÄÅÈü≥È¢ëÊï∞ÊçÆ
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(pcmData.buffer);
      }
    };

    source.connect(processor);
    processor.connect(this.audioContext.destination);
  }

  stop() {
    // ÂÅúÊ≠¢ÂΩïÈü≥
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }

    // ÂèëÈÄÅÁªìÊùü‰ø°Âè∑
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type: 'end_stream' }));
    }

    // ÂÖ≥Èó≠ WebSocket
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

// ‰ΩøÁî®Á§∫‰æã
const asrClient = new StreamingASRClient(
  'ws://localhost:8001/ws/asr/stream',
  {
    model_size: 'base',
    language: 'zh',
    vad_enabled: true,
  },
  {
    onPartialResult: (data) => {
      console.log('ËØÜÂà´‰∏≠:', data.text);
      updateTranscript(data.text, false);
    },
    onFinalResult: (data) => {
      console.log('ÊúÄÁªàÁªìÊûú:', data.text, 'ÁΩÆ‰ø°Â∫¶:', data.confidence);
      updateTranscript(data.text, true);
    },
    onError: (error) => {
      console.error('ASR ÈîôËØØ:', error);
    },
  }
);

// ÂºÄÂßãËØÜÂà´
await asrClient.start();

// ÂÅúÊ≠¢ËØÜÂà´
asrClient.stop();
```

**ÈÖçÁΩÆÊõ¥Êñ∞**:

```yaml
# configs/app/voice-engine.yaml

asr:
  streaming:
    enabled: true
    chunk_duration_ms: 300
    max_silence_duration_ms: 1500
    vad:
      enabled: true
      mode: 3 # 0-3, 3 ÊúÄ‰∏•Ê†º
      min_speech_duration_ms: 250
      max_speech_duration_s: 30

    # ËØÜÂà´Ê®°Âºè
    partial_recognition:
      enabled: true
      interval_seconds: 3
      beam_size: 1

    final_recognition:
      beam_size: 5
      best_of: 5
      temperature: 0.0
      vad_filter: true
      condition_on_previous_text: true
```

**È™åÊî∂Ê†áÂáÜ**:

- [ ] WebSocket ËøûÊé•Á®≥ÂÆöÔºåÊîØÊåÅÈáçËøû
- [ ] VAD Á´ØÁÇπÊ£ÄÊµãÂáÜÁ°ÆÁéá > 95%
- [ ] Â¢ûÈáèËØÜÂà´Âª∂Ëøü < 500ms
- [ ] ÊúÄÁªàËØÜÂà´ÂáÜÁ°ÆÁéá > 90%
- [ ] Âπ∂ÂèëÊîØÊåÅ > 20 ËøûÊé•
- [ ] ÂâçÁ´ØÂÆûÊó∂Â±ïÁ§∫ËØÜÂà´ÁªìÊûú

**Â∑•‰ΩúÈáè**: 4-5 Â§©
**Ë¥£‰ªª‰∫∫**: AI Engineer 1
**Sprint**: Sprint 1 (Week 1-2)

---

### 2. ÈïøÊúüËÆ∞ÂøÜË°∞Âáè

#### ÂΩìÂâçÁä∂ÊÄÅ

- ‚ùå Agent Êó†ÈïøÊúüËÆ∞ÂøÜ
- ‚ùå Êó†Ê≥ï‰∏™ÊÄßÂåñÂØπËØù
- ‚ùå Êó†ËÆ∞ÂøÜÊ£ÄÁ¥¢ËÉΩÂäõ

#### VoiceHelper ÂÆûÁé∞‰∫ÆÁÇπ

- ‚úÖ Milvus ÂêëÈáèÂ≠òÂÇ®
- ‚úÖ Ebbinghaus ÈÅóÂøòÊõ≤Á∫øË°∞Âáè
- ‚úÖ ËÆøÈóÆÈ¢ëÁéáÂ¢ûÂº∫
- ‚úÖ ÈáçË¶ÅÊÄßËØÑÂàÜ

#### ËøÅÁßªËÆ°Âàí

**ÊäÄÊúØÊñπÊ°à**:

```python
# algo/agent-engine/app/memory/vector_memory_manager.py

from pymilvus import Collection, CollectionSchema, FieldSchema, DataType
import numpy as np
from datetime import datetime
from typing import List, Dict
import httpx

class VectorMemoryManager:
    """Âü∫‰∫éÂêëÈáèÁöÑÈïøÊúüËÆ∞ÂøÜÁÆ°ÁêÜ (ÂèÇËÄÉ voicehelper)"""

    def __init__(
        self,
        milvus_url: str = "http://milvus:19530",
        embedding_service_url: str = "http://model-adapter:8002",
        collection_name: str = "agent_memory"
    ):
        self.milvus_url = milvus_url
        self.embedding_service_url = embedding_service_url
        self.collection_name = collection_name
        self._init_collection()

    def _init_collection(self):
        """ÂàùÂßãÂåñ Milvus ÈõÜÂêà"""
        from pymilvus import connections, utility

        # ËøûÊé• Milvus
        connections.connect("default", host=self.milvus_url.split("//")[1].split(":")[0], port="19530")

        # Ê£ÄÊü•ÈõÜÂêàÊòØÂê¶Â≠òÂú®
        if utility.has_collection(self.collection_name):
            collection = Collection(self.collection_name)
            collection.load()
            return

        # ÂàõÂª∫ÈõÜÂêà
        fields = [
            FieldSchema(name="memory_id", dtype=DataType.VARCHAR, max_length=64, is_primary=True),
            FieldSchema(name="user_id", dtype=DataType.VARCHAR, max_length=64),
            FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=2048),
            FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=1536),  # OpenAI embedding
            FieldSchema(name="importance", dtype=DataType.FLOAT),
            FieldSchema(name="created_at", dtype=DataType.INT64),
            FieldSchema(name="access_count", dtype=DataType.INT64),
            FieldSchema(name="last_accessed", dtype=DataType.INT64),
        ]

        schema = CollectionSchema(fields=fields, description="Agent Long-term Memory")
        collection = Collection(name=self.collection_name, schema=schema)

        # ÂàõÂª∫Á¥¢Âºï
        index_params = {
            "metric_type": "L2",
            "index_type": "IVF_FLAT",
            "params": {"nlist": 1024}
        }
        collection.create_index(field_name="embedding", index_params=index_params)
        collection.load()

        logger.info(f"‚úÖ Milvus collection '{self.collection_name}' created")

    async def store_memory(
        self,
        user_id: str,
        content: str,
        importance: float = 0.5
    ) -> str:
        """Â≠òÂÇ®ËÆ∞ÂøÜ"""
        import uuid
        from pymilvus import Collection

        # ÁîüÊàê embedding
        embedding = await self._get_embedding(content)

        memory_id = str(uuid.uuid4())
        memory_data = [{
            "memory_id": memory_id,
            "user_id": user_id,
            "content": content,
            "embedding": embedding,
            "importance": importance,
            "created_at": int(datetime.now().timestamp()),
            "access_count": 0,
            "last_accessed": int(datetime.now().timestamp()),
        }]

        collection = Collection(self.collection_name)
        collection.insert(memory_data)

        logger.info(f"‚úÖ Memory stored: {memory_id} (user: {user_id})")
        return memory_id

    async def retrieve_memory(
        self,
        user_id: str,
        query: str,
        top_k: int = 5,
        time_decay_enabled: bool = True,
        time_decay_half_life_days: int = 30
    ) -> List[Dict]:
        """Ê£ÄÁ¥¢Áõ∏ÂÖ≥ËÆ∞ÂøÜ (Ebbinghaus ÈÅóÂøòÊõ≤Á∫øË°∞Âáè)"""
        from pymilvus import Collection

        # ÁîüÊàêÊü•ËØ¢ÂêëÈáè
        query_embedding = await self._get_embedding(query)

        # ÂêëÈáèÊ£ÄÁ¥¢
        collection = Collection(self.collection_name)
        search_params = {"metric_type": "L2", "params": {"nprobe": 10}}

        results = collection.search(
            data=[query_embedding],
            anns_field="embedding",
            param=search_params,
            limit=top_k * 3,  # Â§öÂè¨Âõû‰∏Ä‰∫õÔºåÂêéÈù¢ÈáçÊéíÂ∫è
            expr=f'user_id == "{user_id}"',
            output_fields=["memory_id", "content", "importance", "created_at", "access_count", "last_accessed"]
        )

        # ÂêéÂ§ÑÁêÜ: Êó∂Èó¥Ë°∞Âáè + ÈáçË¶ÅÊÄßÂä†ÊùÉ + ËÆøÈóÆÈ¢ëÁéáÂ¢ûÂº∫
        memories = []
        current_time = datetime.now().timestamp()

        for hits in results:
            for hit in hits:
                entity = hit.entity

                # 1. ÂêëÈáèÁõ∏‰ººÂ∫¶ÂàÜÊï∞ (L2 Ë∑ùÁ¶ªÔºåË∂äÂ∞èË∂äÂ•Ω)
                vector_score = 1.0 / (1.0 + hit.distance)

                # 2. Ebbinghaus ÈÅóÂøòÊõ≤Á∫øË°∞Âáè
                if time_decay_enabled:
                    time_diff_days = (current_time - entity.get("created_at")) / 86400
                    decay_factor = np.exp(-time_diff_days / time_decay_half_life_days)  # ÂçäË°∞Êúü
                else:
                    decay_factor = 1.0

                # 3. ËÆøÈóÆÈ¢ëÁéáÂ¢ûÂº∫
                access_boost = min(entity.get("access_count", 0) * 0.05, 0.3)  # ÊúÄÂ§öÊèêÂçá 30%

                # 4. ÈáçË¶ÅÊÄßÊùÉÈáç
                importance = entity.get("importance", 0.5)

                # ÁªºÂêàÂæóÂàÜ
                score = (
                    vector_score * 0.4 +  # ÂêëÈáèÁõ∏‰ººÂ∫¶
                    decay_factor * 0.3 +  # Êó∂Èó¥Ë°∞Âáè
                    importance * 0.2 +    # ÈáçË¶ÅÊÄß
                    access_boost * 0.1    # ËÆøÈóÆÈ¢ëÁéá
                )

                memories.append({
                    "memory_id": entity.get("memory_id"),
                    "content": entity.get("content"),
                    "score": score,
                    "vector_score": vector_score,
                    "decay_factor": decay_factor,
                    "importance": importance,
                    "access_count": entity.get("access_count", 0),
                    "created_at": entity.get("created_at"),
                    "days_ago": time_diff_days
                })

        # ÊåâÁªºÂêàÂæóÂàÜÊéíÂ∫èÂπ∂ËøîÂõû top_k
        memories.sort(key=lambda x: x["score"], reverse=True)
        return memories[:top_k]

    async def update_memory_access(self, memory_id: str):
        """Êõ¥Êñ∞ËÆ∞ÂøÜËÆøÈóÆÁªüËÆ°"""
        from pymilvus import Collection

        collection = Collection(self.collection_name)

        # Êü•ËØ¢Áé∞ÊúâËÆ∞ÂøÜ
        expr = f'memory_id == "{memory_id}"'
        results = collection.query(expr=expr, output_fields=["*"])

        if results:
            entity = results[0]
            entity["access_count"] += 1
            entity["last_accessed"] = int(datetime.now().timestamp())

            # Âà†Èô§ÊóßËÆ∞ÂΩï
            collection.delete(expr=expr)

            # ÊèíÂÖ•Êõ¥Êñ∞ÂêéÁöÑËÆ∞ÂΩï
            collection.insert([entity])

            logger.debug(f"‚úÖ Memory access updated: {memory_id} (count: {entity['access_count']})")

    async def _get_embedding(self, text: str) -> List[float]:
        """Ë∞ÉÁî® Model Adapter Ëé∑Âèñ embedding"""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.embedding_service_url}/v1/embeddings",
                json={
                    "model": "text-embedding-ada-002",
                    "input": text
                },
                timeout=30.0
            )

            if response.status_code != 200:
                raise Exception(f"Embedding service error: {response.text}")

            data = response.json()
            return data["data"][0]["embedding"]

    async def evaluate_importance(self, content: str, context: Dict = None) -> float:
        """‰ΩøÁî® LLM ËØÑ‰º∞ËÆ∞ÂøÜÈáçË¶ÅÊÄß (ÂèÇËÄÉ voicehelper)"""

        # ÁÆÄÂåñÂÆûÁé∞: Âü∫‰∫éËßÑÂàô
        # Áîü‰∫ßÁéØÂ¢ÉÂ∫î‰ΩøÁî® LLM ËØÑ‰º∞

        important_keywords = [
            "ÈáçË¶Å", "ËÆ∞‰Ωè", "ÂÖ≥ÈîÆ", "ÂøÖÈ°ª", "Âä°ÂøÖ",
            "ÂñúÊ¨¢", "ËÆ®Âéå", "Áà±", "ÊÅ®",
            "Ê∞∏Ëøú", "‰∏ÄÁõ¥", "‰ªé‰∏ç",
            "ÂêçÂ≠ó", "ÁîüÊó•", "Âú∞ÂùÄ", "ÁîµËØù"
        ]

        score = 0.5  # Âü∫Á°ÄÂàÜ

        for keyword in important_keywords:
            if keyword in content:
                score += 0.1

        # ÈóÆÂè•ÈáçË¶ÅÊÄßËæÉ‰Ωé
        if "?" in content or "Ôºü" in content or "Âêó" in content:
            score -= 0.1

        # ÈïøÂè•ÈáçË¶ÅÊÄßËæÉÈ´ò
        if len(content) > 50:
            score += 0.05

        # ÈôêÂà∂ËåÉÂõ¥
        return min(max(score, 0.0), 1.0)
```

**ÈõÜÊàêÂà∞ Agent**:

```python
# algo/agent-engine/app/memory/memory_manager.py

class MemoryManager:
    """Áªü‰∏ÄËÆ∞ÂøÜÁÆ°ÁêÜÂô®"""

    def __init__(self):
        self.short_term = {}  # ÂØπËØùÁ∫ßÁü≠ÊúüËÆ∞ÂøÜ (ÂÜÖÂ≠ò)
        self.long_term = VectorMemoryManager()  # ÂêëÈáèÂåñÈïøÊúüËÆ∞ÂøÜ (Milvus)

    async def add_to_short_term(self, session_id: str, message: Dict):
        """Ê∑ªÂä†Âà∞Áü≠ÊúüËÆ∞ÂøÜ"""
        if session_id not in self.short_term:
            self.short_term[session_id] = []

        self.short_term[session_id].append(message)

        # ÈôêÂà∂Áü≠ÊúüËÆ∞ÂøÜÂ§ßÂ∞è
        if len(self.short_term[session_id]) > 20:
            self.short_term[session_id] = self.short_term[session_id][-20:]

    async def add_to_long_term(
        self,
        user_id: str,
        content: str,
        auto_evaluate_importance: bool = True
    ) -> str:
        """Ê∑ªÂä†Âà∞ÈïøÊúüËÆ∞ÂøÜ"""

        # ËØÑ‰º∞ÈáçË¶ÅÊÄß
        if auto_evaluate_importance:
            importance = await self.long_term.evaluate_importance(content)
        else:
            importance = 0.5

        # Â≠òÂÇ®
        memory_id = await self.long_term.store_memory(
            user_id=user_id,
            content=content,
            importance=importance
        )

        return memory_id

    async def recall(
        self,
        user_id: str,
        query: str,
        top_k: int = 5
    ) -> List[str]:
        """Âè¨ÂõûÁõ∏ÂÖ≥ÈïøÊúüËÆ∞ÂøÜ"""

        memories = await self.long_term.retrieve_memory(
            user_id=user_id,
            query=query,
            top_k=top_k,
            time_decay_enabled=True,
            time_decay_half_life_days=30
        )

        # Êõ¥Êñ∞ËÆøÈóÆÁªüËÆ°
        for memory in memories:
            await self.long_term.update_memory_access(memory["memory_id"])

        return [m["content"] for m in memories]

    def get_short_term(self, session_id: str, last_n: int = 10) -> List[Dict]:
        """Ëé∑ÂèñÁü≠ÊúüËÆ∞ÂøÜ"""
        return self.short_term.get(session_id, [])[-last_n:]

    def clear_short_term(self, session_id: str):
        """Ê∏ÖÈô§Áü≠ÊúüËÆ∞ÂøÜ"""
        if session_id in self.short_term:
            del self.short_term[session_id]
```

**API Êé•Âè£**:

```python
# algo/agent-engine/routers/memory.py

@router.post("/memory/store")
async def store_memory(request: StoreMemoryRequest):
    """Â≠òÂÇ®ÈïøÊúüËÆ∞ÂøÜ"""

    memory_id = await app.state.memory_manager.add_to_long_term(
        user_id=request.user_id,
        content=request.content,
        auto_evaluate_importance=True
    )

    return {
        "memory_id": memory_id,
        "status": "stored"
    }

@router.post("/memory/recall")
async def recall_memory(request: RecallMemoryRequest):
    """Âè¨ÂõûÁõ∏ÂÖ≥ËÆ∞ÂøÜ"""

    memories = await app.state.memory_manager.recall(
        user_id=request.user_id,
        query=request.query,
        top_k=request.top_k or 5
    )

    return {
        "memories": memories,
        "count": len(memories)
    }
```

**ÈÖçÁΩÆ**:

```yaml
# configs/app/agent-engine.yaml

memory:
  type: 'vector' # "memory" or "vector"

  vector:
    milvus_url: 'http://milvus:19530'
    embedding_service_url: 'http://model-adapter:8002'
    collection_name: 'agent_memory'

    # Êó∂Èó¥Ë°∞Âáè
    time_decay_enabled: true
    time_decay_half_life_days: 30 # 30 Â§©ÂçäË°∞Êúü

    # Ê£ÄÁ¥¢ÂèÇÊï∞
    top_k_candidates: 15 # Âè¨ÂõûÂÄôÈÄâÊï∞
    top_k_final: 5 # ÊúÄÁªàËøîÂõûÊï∞

  short_term:
    max_messages: 20 # Áü≠ÊúüËÆ∞ÂøÜÊúÄÂ§ßÊ∂àÊÅØÊï∞
```

**È™åÊî∂Ê†áÂáÜ**:

- [ ] ËÆ∞ÂøÜÊàêÂäüÂ≠òÂÇ®Âà∞ Milvus
- [ ] ÂêëÈáèÊ£ÄÁ¥¢Âè¨ÂõûÁéá > 80%
- [ ] Êó∂Èó¥Ë°∞ÂáèÊú∫Âà∂ÁîüÊïà
- [ ] ËÆøÈóÆÈ¢ëÁéáÂ¢ûÂº∫ÁîüÊïà
- [ ] ÈáçË¶ÅÊÄßËØÑÂàÜÂêàÁêÜ

**Â∑•‰ΩúÈáè**: 3-4 Â§©
**Ë¥£‰ªª‰∫∫**: AI Engineer 1
**Sprint**: Sprint 1

---

### 3. Redis ‰ªªÂä°ÊåÅ‰πÖÂåñ

#### ÂΩìÂâçÁä∂ÊÄÅ

- ‚ùå Agent ‰ªªÂä°‰ªÖÂ≠òÂÜÖÂ≠ò
- ‚ùå ÊúçÂä°ÈáçÂêØ‰ªªÂä°‰∏¢Â§±
- ‚ùå Êó†Ê≥ïÊü•ËØ¢ÂéÜÂè≤‰ªªÂä°

#### VoiceHelper ÂÆûÁé∞‰∫ÆÁÇπ

- ‚úÖ Redis ÊåÅ‰πÖÂåñ‰ªªÂä°
- ‚úÖ ÊîØÊåÅ‰ªªÂä°Êü•ËØ¢ÂíåÊÅ¢Â§ç
- ‚úÖ TTL Ëá™Âä®ËøáÊúü
- ‚úÖ ‰ªªÂä°Áä∂ÊÄÅËøΩË∏™

#### ËøÅÁßªËÆ°Âàí

**ÊäÄÊúØÊñπÊ°à**:

```python
# algo/agent-engine/app/storage/redis_task_store.py

import redis
import json
from datetime import timedelta, datetime
from typing import Dict, List, Optional

class RedisTaskStore:
    """Âü∫‰∫é Redis ÁöÑ‰ªªÂä°Â≠òÂÇ® (ÂèÇËÄÉ voicehelper)"""

    def __init__(
        self,
        redis_url: str = "redis://localhost:6379/0",
        ttl_days: int = 7
    ):
        self.redis = redis.from_url(redis_url, decode_responses=True)
        self.ttl_days = ttl_days

    def save_task(self, task_id: str, task_data: Dict):
        """‰øùÂ≠ò‰ªªÂä°"""
        key = f"agent:task:{task_id}"

        # Ê∑ªÂä†ÂÖÉÊï∞ÊçÆ
        task_data["_updated_at"] = datetime.now().isoformat()

        self.redis.setex(
            key,
            timedelta(days=self.ttl_days),
            json.dumps(task_data, ensure_ascii=False)
        )

        # Ê∑ªÂä†Âà∞‰ªªÂä°ÂàóË°® (Áî®‰∫éÊü•ËØ¢)
        list_key = f"agent:tasks:{task_data.get('user_id', 'unknown')}"
        self.redis.lpush(list_key, task_id)
        self.redis.expire(list_key, timedelta(days=self.ttl_days))

        logger.debug(f"‚úÖ Task saved to Redis: {task_id}")

    def get_task(self, task_id: str) -> Optional[Dict]:
        """Ëé∑Âèñ‰ªªÂä°"""
        key = f"agent:task:{task_id}"
        data = self.redis.get(key)

        if data:
            return json.loads(data)

        return None

    def update_task(self, task_id: str, updates: Dict):
        """Êõ¥Êñ∞‰ªªÂä°"""
        task = self.get_task(task_id)

        if task:
            task.update(updates)
            self.save_task(task_id, task)

    def delete_task(self, task_id: str):
        """Âà†Èô§‰ªªÂä°"""
        key = f"agent:task:{task_id}"
        self.redis.delete(key)

        logger.debug(f"‚ùå Task deleted from Redis: {task_id}")

    def list_tasks(
        self,
        user_id: Optional[str] = None,
        status: Optional[str] = None,
        limit: int = 50
    ) -> List[Dict]:
        """ÂàóÂá∫‰ªªÂä°"""

        tasks = []

        if user_id:
            # Êü•ËØ¢Áî®Êà∑ÁöÑ‰ªªÂä°
            list_key = f"agent:tasks:{user_id}"
            task_ids = self.redis.lrange(list_key, 0, limit - 1)

            for task_id in task_ids:
                task = self.get_task(task_id)
                if task:
                    if not status or task.get("status") == status:
                        tasks.append(task)
        else:
            # Êâ´ÊèèÊâÄÊúâ‰ªªÂä°
            keys = self.redis.keys("agent:task:*")

            for key in keys[:limit]:
                data = self.redis.get(key)
                if data:
                    task = json.loads(data)
                    if not status or task.get("status") == status:
                        tasks.append(task)

        # ÊåâÂàõÂª∫Êó∂Èó¥ÊéíÂ∫è
        tasks.sort(key=lambda x: x.get("created_at", ""), reverse=True)

        return tasks

    def get_stats(self) -> Dict:
        """Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ"""

        # ÁªüËÆ°ÂêÑÁä∂ÊÄÅ‰ªªÂä°Êï∞
        keys = list(self.redis.scan_iter("agent:task:*"))

        stats = {
            "total": len(keys),
            "by_status": {}
        }

        for key in keys:
            data = self.redis.get(key)
            if data:
                task = json.loads(data)
                status = task.get("status", "unknown")
                stats["by_status"][status] = stats["by_status"].get(status, 0) + 1

        return stats
```

**ÈõÜÊàêÂà∞ Agent Service**:

```python
# algo/agent-engine/app/core/agent_service.py

class AgentService:

    def __init__(self):
        self.task_store = RedisTaskStore()  # Êõø‰ª£ÂÜÖÂ≠òÂ≠òÂÇ®
        # ...

    async def execute_async(
        self,
        task: AgentTask,
        background_tasks: BackgroundTasks
    ) -> str:
        """ÂºÇÊ≠•ÊâßË°å‰ªªÂä°"""

        task_id = task.task_id

        # ÂàõÂª∫‰ªªÂä°ËÆ∞ÂΩï (ÊåÅ‰πÖÂåñÂà∞ Redis)
        self.task_store.save_task(task_id, {
            "task_id": task_id,
            "user_id": task.user_id,
            "task": task.task,
            "status": "pending",
            "created_at": datetime.now().isoformat(),
            "request": task.dict()
        })

        # ÂêéÂè∞ÊâßË°å
        background_tasks.add_task(
            self._execute_task_background,
            task_id=task_id,
            task=task
        )

        return task_id

    async def _execute_task_background(self, task_id: str, task: AgentTask):
        """ÂêéÂè∞ÊâßË°å‰ªªÂä°"""

        # Êõ¥Êñ∞Áä∂ÊÄÅ
        self.task_store.update_task(task_id, {
            "status": "running",
            "started_at": datetime.now().isoformat()
        })

        try:
            # ÊâßË°å‰ªªÂä°
            result = await self._execute_task(task)

            # Êõ¥Êñ∞ÁªìÊûú
            self.task_store.update_task(task_id, {
                "status": "completed",
                "result": result,
                "completed_at": datetime.now().isoformat()
            })

        except Exception as e:
            # Êõ¥Êñ∞ÈîôËØØ
            self.task_store.update_task(task_id, {
                "status": "failed",
                "error": str(e),
                "failed_at": datetime.now().isoformat()
            })

    async def get_task_status(self, task_id: str) -> Dict:
        """Êü•ËØ¢‰ªªÂä°Áä∂ÊÄÅ"""

        task = self.task_store.get_task(task_id)

        if not task:
            raise HTTPException(404, "‰ªªÂä°‰∏çÂ≠òÂú®")

        return task

    async def cancel_task(self, task_id: str):
        """ÂèñÊ∂à‰ªªÂä°"""

        task = self.task_store.get_task(task_id)

        if not task:
            raise HTTPException(404, "‰ªªÂä°‰∏çÂ≠òÂú®")

        if task["status"] in ["completed", "failed"]:
            raise HTTPException(400, "‰ªªÂä°Â∑≤ÁªìÊùüÔºåÊó†Ê≥ïÂèñÊ∂à")

        self.task_store.update_task(task_id, {
            "status": "cancelled",
            "cancelled_at": datetime.now().isoformat()
        })
```

**API Êé•Âè£**:

```python
# algo/agent-engine/routers/agent.py

@router.get("/tasks/{task_id}")
async def get_task_status(task_id: str):
    """Êü•ËØ¢‰ªªÂä°Áä∂ÊÄÅ"""

    task = await agent_service.get_task_status(task_id)

    return task

@router.get("/tasks")
async def list_tasks(
    user_id: Optional[str] = None,
    status: Optional[str] = None,
    limit: int = 50
):
    """ÂàóÂá∫‰ªªÂä°"""

    tasks = agent_service.task_store.list_tasks(
        user_id=user_id,
        status=status,
        limit=limit
    )

    return {
        "tasks": tasks,
        "count": len(tasks)
    }

@router.delete("/tasks/{task_id}")
async def cancel_task(task_id: str):
    """ÂèñÊ∂à‰ªªÂä°"""

    await agent_service.cancel_task(task_id)

    return {"message": "‰ªªÂä°Â∑≤ÂèñÊ∂à"}

@router.get("/tasks/stats")
async def get_task_stats():
    """Ëé∑Âèñ‰ªªÂä°ÁªüËÆ°"""

    stats = agent_service.task_store.get_stats()

    return stats
```

**È™åÊî∂Ê†áÂáÜ**:

- [ ] ‰ªªÂä°ÊàêÂäüÊåÅ‰πÖÂåñÂà∞ Redis
- [ ] ÊúçÂä°ÈáçÂêØÂêé‰ªªÂä°ÂèØÊÅ¢Â§ç
- [ ] ‰ªªÂä°Êü•ËØ¢ÂäüËÉΩÊ≠£Â∏∏
- [ ] TTL Ëá™Âä®ËøáÊúüÁîüÊïà
- [ ] ‰ªªÂä°Áä∂ÊÄÅËøΩË∏™ÂáÜÁ°Æ

**Â∑•‰ΩúÈáè**: 2-3 Â§©
**Ë¥£‰ªª‰∫∫**: Backend Engineer 2
**Sprint**: Sprint 2

---

## üìÖ ËøÅÁßªÊó∂Èó¥Á∫ø

### Sprint 1 (Week 1-2): P0 Ê†∏ÂøÉÂäüËÉΩ

| ‰ªªÂä°          | Â∑•‰ΩúÈáè | Ë¥üË¥£‰∫∫   | Áä∂ÊÄÅ |
| ------------- | ------ | -------- | ---- |
| ÊµÅÂºè ASR ËØÜÂà´ | 4-5 Â§© | AI Eng 1 | üìù   |
| ÈïøÊúüËÆ∞ÂøÜË°∞Âáè  | 3-4 Â§© | AI Eng 1 | üìù   |

**È™åÊî∂**: ÊµÅÂºè ASR ÂèØÁî®ÔºåAgent ÊúâÈïøÊúüËÆ∞ÂøÜ

---

### Sprint 2 (Week 3-4): Âü∫Á°ÄËÆæÊñΩÂ¢ûÂº∫

| ‰ªªÂä°             | Â∑•‰ΩúÈáè | Ë¥üË¥£‰∫∫        | Áä∂ÊÄÅ |
| ---------------- | ------ | ------------- | ---- |
| Redis ‰ªªÂä°ÊåÅ‰πÖÂåñ | 2-3 Â§© | Backend Eng 2 | üìù   |
| ÂàÜÂ∏ÉÂºèÈôêÊµÅÂô®     | 2-3 Â§© | Backend Eng 1 | üìù   |
| Consul ÊúçÂä°ÂèëÁé∞  | 4-5 Â§© | SRE           | üìù   |

**È™åÊî∂**: ‰ªªÂä°ÊåÅ‰πÖÂåñÔºåÈôêÊµÅÁîüÊïàÔºåÊúçÂä°ÂèëÁé∞ÂèØÁî®

---

### Sprint 3 (Week 5-6): Ê®°Âûã‰∏éÁü•ËØÜÁÆ°ÁêÜ

| ‰ªªÂä°           | Â∑•‰ΩúÈáè | Ë¥üË¥£‰∫∫        | Áä∂ÊÄÅ |
| -------------- | ------ | ------------- | ---- |
| GLM-4 Ê®°ÂûãÊîØÊåÅ | 2 Â§©   | Backend Eng 1 | üìù   |
| ÊñáÊ°£ÁâàÊú¨ÁÆ°ÁêÜ   | 3-4 Â§© | Backend Eng 2 | üìù   |

**È™åÊî∂**: GLM-4 ÂèØÁî®ÔºåÊñáÊ°£ÁâàÊú¨ÁÆ°ÁêÜÊ≠£Â∏∏

---

### Sprint 4 (Week 7-8): ÂÆâÂÖ®‰∏éÈÄöÁü•

| ‰ªªÂä°              | Â∑•‰ΩúÈáè | Ë¥üË¥£‰∫∫        | Áä∂ÊÄÅ |
| ----------------- | ------ | ------------- | ---- |
| ÁóÖÊØíÊâ´Êèè (ClamAV) | 2-3 Â§© | Backend Eng 2 | üìù   |
| Push ÈÄöÁü•         | 3-4 Â§© | Backend Eng 1 | üìù   |

**È™åÊî∂**: ÁóÖÊØíÊâ´ÊèèÊã¶Êà™ÊÅ∂ÊÑèÊñá‰ª∂ÔºåÊé®ÈÄÅÈÄöÁü•ÂèØÁî®

---

### Sprint 5 (Week 9-10): È´òÁ∫ßÁâπÊÄß

| ‰ªªÂä°     | Â∑•‰ΩúÈáè | Ë¥üË¥£‰∫∫   | Áä∂ÊÄÅ |
| -------- | ------ | -------- | ---- |
| ÊÉÖÊÑüËØÜÂà´ | 3-4 Â§© | AI Eng 2 | üìù   |

**È™åÊî∂**: ËØ≠Èü≥ÊÉÖÊÑüËØÜÂà´ÂáÜÁ°ÆÁéá > 80%

---

## üí∞ ÊàêÊú¨‰º∞ÁÆó

### ‰∫∫ÂäõÊàêÊú¨

| ËßíËâ≤             | ‰∫∫Êï∞  | Êó∂Èó¥     | ÊàêÊú¨ (ÂÅáËÆæÂπ¥Ëñ™ $80k) |
| ---------------- | ----- | -------- | -------------------- |
| AI Engineer      | 2     | 8 Âë®     | $24,615              |
| Backend Engineer | 2     | 8 Âë®     | $24,615              |
| SRE Engineer     | 1     | 4 Âë®     | $6,154               |
| **ÊÄªËÆ°**         | **5** | **8 Âë®** | **$55,384**          |

### Âü∫Á°ÄËÆæÊñΩÊàêÊú¨

| ËµÑÊ∫ê                 | ÊúàÊàêÊú¨   | 2 ‰∏™ÊúàÊÄªËÆ° |
| -------------------- | -------- | ---------- |
| ClamAV ÊúçÂä°Âô®        | $50      | $100       |
| Consul ÈõÜÁæ§ (3 ËäÇÁÇπ) | $150     | $300       |
| **ÊÄªËÆ°**             | **$200** | **$400**   |

### API ÊàêÊú¨

| ÊúçÂä°            | ÊúàÊàêÊú¨        | 2 ‰∏™ÊúàÊÄªËÆ°      |
| --------------- | ------------- | --------------- |
| Êô∫Ë∞± AI (GLM-4) | $300-$600     | $600-$1,200     |
| Firebase FCM    | $0            | $0              |
| Apple APNs      | $0            | $0              |
| **ÊÄªËÆ°**        | **$300-$600** | **$600-$1,200** |

### ÊÄªÊàêÊú¨‰º∞ÁÆó

**ÊÄªËÆ°**: $56,384 - $57,984 (Á∫¶ $57k)

**ÂØπÊØîÂÆåÂÖ®Ëá™Á†î**: ËäÇÁúÅÁ∫¶ $40k-$60k

---

## üéØ ÊàêÂäüÊåáÊ†á

### ÊäÄÊúØÊåáÊ†á

| ÊåáÊ†á             | ÂΩìÂâç       | ËøÅÁßªÂêéÁõÆÊ†á   | ÊèêÂçá  |
| ---------------- | ---------- | ------------ | ----- |
| Agent ËÆ∞ÂøÜÂè¨ÂõûÁéá | 0%         | > 80%        | +‚àû    |
| ASR ÂÆûÊó∂ÊÄß       | ~1.5s ÊâπÈáè | < 500ms ÊµÅÂºè | +67%  |
| ‰ªªÂä°ÊåÅ‰πÖÂåñÁéá     | 0%         | 100%         | +100% |
| ÈôêÊµÅÂáÜÁ°ÆÊÄß       | Êú¨Âú∞‰∏çÂáÜ   | ÂàÜÂ∏ÉÂºèÂáÜÁ°Æ   | ‚úÖ    |
| Ê®°ÂûãÊîØÊåÅÊï∞       | 2          | 3 (Âä† GLM-4) | +50%  |
| ÊñáÊ°£ÂÆâÂÖ®ÊÄß       | Êó†Êâ´Êèè     | ÁóÖÊØíÊâ´Êèè     | ‚úÖ    |
| ÊúçÂä°ÂèëÁé∞         | ÈùôÊÄÅÈÖçÁΩÆ   | Âä®ÊÄÅÂèëÁé∞     | ‚úÖ    |

### ‰∏öÂä°ÊåáÊ†á

| ÊåáÊ†á           | È¢ÑÊúüÊèêÂçá |
| -------------- | -------- |
| Áî®Êà∑Êª°ÊÑèÂ∫¶     | +30%     |
| ÂØπËØù‰∏™ÊÄßÂåñÁ®ãÂ∫¶ | +50%     |
| Á≥ªÁªüÁ®≥ÂÆöÊÄß     | +40%     |
| ÂÆâÂÖ®‰∫ã‰ª∂       | -90%     |

---

## ‚ö†Ô∏è È£éÈô©‰∏éÁºìËß£

### È´òÈ£éÈô©

1. **Milvus ÊÄßËÉΩÁì∂È¢à** (Ê¶ÇÁéá: ‰∏≠, ÂΩ±Âìç: È´ò)

   - **ÁºìËß£**: ÊèêÂâçÂéãÊµãÔºå‰ºòÂåñÁ¥¢ÂºïÂèÇÊï∞ÔºåÂøÖË¶ÅÊó∂ÂàÜÁâá

2. **WebSocket Á®≥ÂÆöÊÄß** (Ê¶ÇÁéá: ‰∏≠, ÂΩ±Âìç: È´ò)

   - **ÁºìËß£**: ÂÆûÁé∞ÂøÉË∑≥Ê£ÄÊµãÂíåËá™Âä®ÈáçËøûÊú∫Âà∂

3. **GLM-4 API Á®≥ÂÆöÊÄß** (Ê¶ÇÁéá: ‰∏≠, ÂΩ±Âìç: ‰∏≠)
   - **ÁºìËß£**: ÂÆûÁé∞ÈôçÁ∫ßÁ≠ñÁï•ÔºåÂ§áÁî® GPT-3.5

### ‰∏≠È£éÈô©

4. **ClamAV Êâ´ÊèèÂª∂Ëøü** (Ê¶ÇÁéá: È´ò, ÂΩ±Âìç: ‰∏≠)

   - **ÁºìËß£**: ÂºÇÊ≠•Êâ´Êèè + ÂºÇÊ≠•ÈÄöÁü•

5. **Redis ÂÜÖÂ≠ò‰ΩøÁî®** (Ê¶ÇÁéá: ‰∏≠, ÂΩ±Âìç: ‰∏≠)
   - **ÁºìËß£**: ÂêàÁêÜËÆæÁΩÆ TTLÔºåÁõëÊéßÂÜÖÂ≠ò‰ΩøÁî®

---

## ‚úÖ È™åÊî∂Ê∏ÖÂçï

### Sprint 1 È™åÊî∂

- [ ] ÊµÅÂºè ASR WebSocket ËøûÊé•Á®≥ÂÆö
- [ ] VAD Á´ØÁÇπÊ£ÄÊµãÂáÜÁ°ÆÁéá > 95%
- [ ] ASR ÂÆûÊó∂Âª∂Ëøü < 500ms
- [ ] Agent ËÆ∞ÂøÜÂ≠òÂÇ®Âà∞ Milvus
- [ ] ËÆ∞ÂøÜÊ£ÄÁ¥¢Âè¨ÂõûÁéá > 80%
- [ ] Êó∂Èó¥Ë°∞ÂáèÊú∫Âà∂ÁîüÊïà

### Sprint 2 È™åÊî∂

- [ ] ‰ªªÂä°ÊåÅ‰πÖÂåñÂà∞ Redis
- [ ] ÊúçÂä°ÈáçÂêØ‰ªªÂä°ÂèØÊÅ¢Â§ç
- [ ] ÂàÜÂ∏ÉÂºèÈôêÊµÅÂô®ÁîüÊïà
- [ ] Consul ÊúçÂä°Ê≥®ÂÜåÊàêÂäü
- [ ] ÊúçÂä°ÂÅ•Â∫∑Ê£ÄÊü•Ê≠£Â∏∏

### Sprint 3 È™åÊî∂

- [ ] GLM-4 Ê®°ÂûãÂèØÁî®
- [ ] ÊñáÊ°£ÁâàÊú¨ÂàõÂª∫/ÂõûÊªöÊ≠£Â∏∏
- [ ] ÁâàÊú¨ÊØîÂØπÂäüËÉΩÂèØÁî®

### Sprint 4 È™åÊî∂

- [ ] ClamAV Êâ´ÊèèÊã¶Êà™ÊÅ∂ÊÑèÊñá‰ª∂
- [ ] Êâ´ÊèèÂª∂Ëøü < 3s
- [ ] FCM/APNs Êé®ÈÄÅÈÄöÁü•ÊàêÂäü
- [ ] ËÆæÂ§á Token ÁÆ°ÁêÜÊ≠£Â∏∏

### Sprint 5 È™åÊî∂

- [ ] ÊÉÖÊÑüËØÜÂà´ÂáÜÁ°ÆÁéá > 80%
- [ ] ÊîØÊåÅ 7 ÁßçÊÉÖÊÑüÂàÜÁ±ª
- [ ] ÂÆûÊó∂ÊÉÖÊÑüÂàÜÊûêÂª∂Ëøü < 200ms

---

## üìö ÂèÇËÄÉÊñáÊ°£

### VoiceHelper ÂèÇËÄÉ

- GitHub: https://github.com/haoyunlt/voicehelper
- README: ÂÆåÊï¥ÂäüËÉΩËØ¥Êòé
- v0.9.2 Release Notes: ÊúÄÊñ∞ÁâπÊÄß

### ÂÜÖÈÉ®ÊñáÊ°£

- [SERVICES_ITERATION_MASTER_PLAN.md](SERVICES_ITERATION_MASTER_PLAN.md) - ÊÄª‰ΩìËø≠‰ª£ËÆ°Âàí
- [SERVICE_AGENT_ENGINE_PLAN.md](SERVICE_AGENT_ENGINE_PLAN.md) - Agent ÂºïÊìéËØ¶ÁªÜËÆ°Âàí
- [SERVICE_VOICE_ENGINE_PLAN.md](SERVICE_VOICE_ENGINE_PLAN.md) - ËØ≠Èü≥ÂºïÊìéËØ¶ÁªÜËÆ°Âàí

---

## üìû ËÅîÁ≥ªÊñπÂºè

**È°πÁõÆË¥üË¥£‰∫∫**: [ÂæÖÂÆö]
**ÊäÄÊúØÂØπÊé•**: [ÂæÖÂÆö]

---

**ÊñáÊ°£ÁâàÊú¨**: v1.0.0
**ÁîüÊàêÊó•Êúü**: 2025-10-27
**‰∏ãÊ¨°ÂÆ°Êü•**: Sprint 2 ÁªìÊùüÂêé

---

**ËÆ©Êàë‰ª¨Âø´ÈÄüËøÅÁßª VoiceHelper ÁöÑ‰ºòÁßÄÁâπÊÄßÔºåÂä†ÈÄü VoiceAssistant ÁöÑÂºÄÂèëËøõÂ∫¶ÔºÅüöÄ**
