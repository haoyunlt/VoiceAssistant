// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: vector-store/v1/vector_store.proto

package vectorstorev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VectorStoreService_CreateCollection_FullMethodName   = "/vector_store.v1.VectorStoreService/CreateCollection"
	VectorStoreService_DeleteCollection_FullMethodName   = "/vector_store.v1.VectorStoreService/DeleteCollection"
	VectorStoreService_ListCollections_FullMethodName    = "/vector_store.v1.VectorStoreService/ListCollections"
	VectorStoreService_GetCollectionInfo_FullMethodName  = "/vector_store.v1.VectorStoreService/GetCollectionInfo"
	VectorStoreService_InsertVectors_FullMethodName      = "/vector_store.v1.VectorStoreService/InsertVectors"
	VectorStoreService_InsertVectorsBatch_FullMethodName = "/vector_store.v1.VectorStoreService/InsertVectorsBatch"
	VectorStoreService_UpdateVector_FullMethodName       = "/vector_store.v1.VectorStoreService/UpdateVector"
	VectorStoreService_DeleteVector_FullMethodName       = "/vector_store.v1.VectorStoreService/DeleteVector"
	VectorStoreService_DeleteVectorsBatch_FullMethodName = "/vector_store.v1.VectorStoreService/DeleteVectorsBatch"
	VectorStoreService_Search_FullMethodName             = "/vector_store.v1.VectorStoreService/Search"
	VectorStoreService_SearchBatch_FullMethodName        = "/vector_store.v1.VectorStoreService/SearchBatch"
	VectorStoreService_HealthCheck_FullMethodName        = "/vector_store.v1.VectorStoreService/HealthCheck"
)

// VectorStoreServiceClient is the client API for VectorStoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VectorStoreService 向量存储适配器服务
type VectorStoreServiceClient interface {
	// 创建集合
	CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error)
	// 删除集合
	DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 列出集合
	ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error)
	// 获取集合信息
	GetCollectionInfo(ctx context.Context, in *GetCollectionInfoRequest, opts ...grpc.CallOption) (*CollectionInfo, error)
	// 插入向量
	InsertVectors(ctx context.Context, in *InsertVectorsRequest, opts ...grpc.CallOption) (*InsertVectorsResponse, error)
	// 批量插入
	InsertVectorsBatch(ctx context.Context, in *InsertVectorsBatchRequest, opts ...grpc.CallOption) (*InsertVectorsBatchResponse, error)
	// 更新向量
	UpdateVector(ctx context.Context, in *UpdateVectorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 删除向量
	DeleteVector(ctx context.Context, in *DeleteVectorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 批量删除
	DeleteVectorsBatch(ctx context.Context, in *DeleteVectorsBatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 向量检索
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// 批量检索
	SearchBatch(ctx context.Context, in *SearchBatchRequest, opts ...grpc.CallOption) (*SearchBatchResponse, error)
	// 健康检查
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type vectorStoreServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVectorStoreServiceClient(cc grpc.ClientConnInterface) VectorStoreServiceClient {
	return &vectorStoreServiceClient{cc}
}

func (c *vectorStoreServiceClient) CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCollectionResponse)
	err := c.cc.Invoke(ctx, VectorStoreService_CreateCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VectorStoreService_DeleteCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCollectionsResponse)
	err := c.cc.Invoke(ctx, VectorStoreService_ListCollections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) GetCollectionInfo(ctx context.Context, in *GetCollectionInfoRequest, opts ...grpc.CallOption) (*CollectionInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CollectionInfo)
	err := c.cc.Invoke(ctx, VectorStoreService_GetCollectionInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) InsertVectors(ctx context.Context, in *InsertVectorsRequest, opts ...grpc.CallOption) (*InsertVectorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertVectorsResponse)
	err := c.cc.Invoke(ctx, VectorStoreService_InsertVectors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) InsertVectorsBatch(ctx context.Context, in *InsertVectorsBatchRequest, opts ...grpc.CallOption) (*InsertVectorsBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertVectorsBatchResponse)
	err := c.cc.Invoke(ctx, VectorStoreService_InsertVectorsBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) UpdateVector(ctx context.Context, in *UpdateVectorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VectorStoreService_UpdateVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) DeleteVector(ctx context.Context, in *DeleteVectorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VectorStoreService_DeleteVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) DeleteVectorsBatch(ctx context.Context, in *DeleteVectorsBatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VectorStoreService_DeleteVectorsBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, VectorStoreService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) SearchBatch(ctx context.Context, in *SearchBatchRequest, opts ...grpc.CallOption) (*SearchBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchBatchResponse)
	err := c.cc.Invoke(ctx, VectorStoreService_SearchBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorStoreServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, VectorStoreService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VectorStoreServiceServer is the server API for VectorStoreService service.
// All implementations must embed UnimplementedVectorStoreServiceServer
// for forward compatibility.
//
// VectorStoreService 向量存储适配器服务
type VectorStoreServiceServer interface {
	// 创建集合
	CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error)
	// 删除集合
	DeleteCollection(context.Context, *DeleteCollectionRequest) (*emptypb.Empty, error)
	// 列出集合
	ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error)
	// 获取集合信息
	GetCollectionInfo(context.Context, *GetCollectionInfoRequest) (*CollectionInfo, error)
	// 插入向量
	InsertVectors(context.Context, *InsertVectorsRequest) (*InsertVectorsResponse, error)
	// 批量插入
	InsertVectorsBatch(context.Context, *InsertVectorsBatchRequest) (*InsertVectorsBatchResponse, error)
	// 更新向量
	UpdateVector(context.Context, *UpdateVectorRequest) (*emptypb.Empty, error)
	// 删除向量
	DeleteVector(context.Context, *DeleteVectorRequest) (*emptypb.Empty, error)
	// 批量删除
	DeleteVectorsBatch(context.Context, *DeleteVectorsBatchRequest) (*emptypb.Empty, error)
	// 向量检索
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// 批量检索
	SearchBatch(context.Context, *SearchBatchRequest) (*SearchBatchResponse, error)
	// 健康检查
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedVectorStoreServiceServer()
}

// UnimplementedVectorStoreServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVectorStoreServiceServer struct{}

func (UnimplementedVectorStoreServiceServer) CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCollection not implemented")
}
func (UnimplementedVectorStoreServiceServer) DeleteCollection(context.Context, *DeleteCollectionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (UnimplementedVectorStoreServiceServer) ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCollections not implemented")
}
func (UnimplementedVectorStoreServiceServer) GetCollectionInfo(context.Context, *GetCollectionInfoRequest) (*CollectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollectionInfo not implemented")
}
func (UnimplementedVectorStoreServiceServer) InsertVectors(context.Context, *InsertVectorsRequest) (*InsertVectorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertVectors not implemented")
}
func (UnimplementedVectorStoreServiceServer) InsertVectorsBatch(context.Context, *InsertVectorsBatchRequest) (*InsertVectorsBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertVectorsBatch not implemented")
}
func (UnimplementedVectorStoreServiceServer) UpdateVector(context.Context, *UpdateVectorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVector not implemented")
}
func (UnimplementedVectorStoreServiceServer) DeleteVector(context.Context, *DeleteVectorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVector not implemented")
}
func (UnimplementedVectorStoreServiceServer) DeleteVectorsBatch(context.Context, *DeleteVectorsBatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVectorsBatch not implemented")
}
func (UnimplementedVectorStoreServiceServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedVectorStoreServiceServer) SearchBatch(context.Context, *SearchBatchRequest) (*SearchBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBatch not implemented")
}
func (UnimplementedVectorStoreServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedVectorStoreServiceServer) mustEmbedUnimplementedVectorStoreServiceServer() {}
func (UnimplementedVectorStoreServiceServer) testEmbeddedByValue()                            {}

// UnsafeVectorStoreServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VectorStoreServiceServer will
// result in compilation errors.
type UnsafeVectorStoreServiceServer interface {
	mustEmbedUnimplementedVectorStoreServiceServer()
}

func RegisterVectorStoreServiceServer(s grpc.ServiceRegistrar, srv VectorStoreServiceServer) {
	// If the following call pancis, it indicates UnimplementedVectorStoreServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VectorStoreService_ServiceDesc, srv)
}

func _VectorStoreService_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_CreateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).CreateCollection(ctx, req.(*CreateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_DeleteCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).DeleteCollection(ctx, req.(*DeleteCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_ListCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).ListCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_ListCollections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).ListCollections(ctx, req.(*ListCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_GetCollectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).GetCollectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_GetCollectionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).GetCollectionInfo(ctx, req.(*GetCollectionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_InsertVectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertVectorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).InsertVectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_InsertVectors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).InsertVectors(ctx, req.(*InsertVectorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_InsertVectorsBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertVectorsBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).InsertVectorsBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_InsertVectorsBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).InsertVectorsBatch(ctx, req.(*InsertVectorsBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_UpdateVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).UpdateVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_UpdateVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).UpdateVector(ctx, req.(*UpdateVectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_DeleteVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).DeleteVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_DeleteVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).DeleteVector(ctx, req.(*DeleteVectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_DeleteVectorsBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVectorsBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).DeleteVectorsBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_DeleteVectorsBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).DeleteVectorsBatch(ctx, req.(*DeleteVectorsBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_SearchBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).SearchBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_SearchBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).SearchBatch(ctx, req.(*SearchBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorStoreService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorStoreServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorStoreService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorStoreServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VectorStoreService_ServiceDesc is the grpc.ServiceDesc for VectorStoreService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VectorStoreService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vector_store.v1.VectorStoreService",
	HandlerType: (*VectorStoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCollection",
			Handler:    _VectorStoreService_CreateCollection_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _VectorStoreService_DeleteCollection_Handler,
		},
		{
			MethodName: "ListCollections",
			Handler:    _VectorStoreService_ListCollections_Handler,
		},
		{
			MethodName: "GetCollectionInfo",
			Handler:    _VectorStoreService_GetCollectionInfo_Handler,
		},
		{
			MethodName: "InsertVectors",
			Handler:    _VectorStoreService_InsertVectors_Handler,
		},
		{
			MethodName: "InsertVectorsBatch",
			Handler:    _VectorStoreService_InsertVectorsBatch_Handler,
		},
		{
			MethodName: "UpdateVector",
			Handler:    _VectorStoreService_UpdateVector_Handler,
		},
		{
			MethodName: "DeleteVector",
			Handler:    _VectorStoreService_DeleteVector_Handler,
		},
		{
			MethodName: "DeleteVectorsBatch",
			Handler:    _VectorStoreService_DeleteVectorsBatch_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _VectorStoreService_Search_Handler,
		},
		{
			MethodName: "SearchBatch",
			Handler:    _VectorStoreService_SearchBatch_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _VectorStoreService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vector-store/v1/vector_store.proto",
}
