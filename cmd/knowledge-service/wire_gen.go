// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"time"

	"voiceassistant/cmd/knowledge-service/internal/biz"
	"voiceassistant/cmd/knowledge-service/internal/data"
	"voiceassistant/cmd/knowledge-service/internal/infrastructure/event"
	"voiceassistant/cmd/knowledge-service/internal/infrastructure/security"
	"voiceassistant/cmd/knowledge-service/internal/infrastructure/storage"
	"voiceassistant/cmd/knowledge-service/internal/server"
	"voiceassistant/cmd/knowledge-service/internal/service"

	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
)

// Injectors from wire.go:

// wireApp init kratos application.
func wireApp(c *Config, logger log.Logger) (*kratos.App, func(), error) {
	grpcConfig := provideGRPCConfig(c)
	config := provideDataConfig(c)
	db, err := data.NewDB(config, logger)
	if err != nil {
		return nil, nil, err
	}
	dataData, cleanup, err := data.NewData(db, logger)
	if err != nil {
		return nil, nil, err
	}
	knowledgeBaseRepository := data.NewKnowledgeBaseRepo(dataData, logger)
	documentRepository := data.NewDocumentRepo(dataData, logger)
	knowledgeBaseUsecase := biz.NewKnowledgeBaseUsecase(knowledgeBaseRepository, documentRepository, logger)
	minIOConfig := provideStorageConfig(c)
	minIOClient, err := storage.NewMinIOClient(minIOConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	clamAVConfig := provideSecurityConfig(c)
	clamAVScanner := security.NewClamAVScanner(clamAVConfig)
	eventPublisherConfig := provideEventConfig(c)
	eventPublisher := event.NewEventPublisher(eventPublisherConfig)
	documentUsecase := biz.NewDocumentUsecase(documentRepository, knowledgeBaseUsecase, minIOClient, clamAVScanner, eventPublisher, logger)
	knowledgeService := service.NewKnowledgeService(knowledgeBaseUsecase, documentUsecase, logger)
	grpcServer := server.NewGRPCServer(grpcConfig, knowledgeService, logger)
	httpConfig := provideHTTPConfig(c)
	httpServer := server.NewHTTPServer(httpConfig, knowledgeService, logger)
	app := newApp(logger, grpcServer, httpServer)
	return app, func() {
		cleanup()
	}, nil
}

// wire.go:

// provideDataConfig converts main Config to data.Config
func provideDataConfig(c *Config) *data.Config {
	return &c.Data.Database
}

// provideStorageConfig converts main Config to storage.MinIOConfig
func provideStorageConfig(c *Config) storage.MinIOConfig {
	return storage.MinIOConfig{
		Endpoint:        c.Storage.Endpoint,
		AccessKeyID:     c.Storage.AccessKeyID,
		SecretAccessKey: c.Storage.SecretAccessKey,
		BucketName:      c.Storage.BucketName,
		UseSSL:          c.Storage.UseSSL,
	}
}

// provideEventConfig converts main Config to event.EventPublisherConfig
func provideEventConfig(c *Config) event.EventPublisherConfig {
	return event.EventPublisherConfig{
		Brokers: c.Event.Brokers,
		Topic:   c.Event.Topic,
	}
}

// provideSecurityConfig converts main Config to security.ClamAVConfig
func provideSecurityConfig(c *Config) security.ClamAVConfig {
	timeout, _ := time.ParseDuration(c.Security.ClamAV.Timeout)
	if timeout == 0 {
		timeout = 30 * time.Second
	}
	return security.ClamAVConfig{
		Host:    c.Security.ClamAV.Host,
		Port:    c.Security.ClamAV.Port,
		Timeout: timeout,
	}
}

// provideHTTPConfig converts main Config to server.HTTPConfig
func provideHTTPConfig(c *Config) *server.HTTPConfig {
	return &server.HTTPConfig{
		Network: c.Server.HTTP.Network,
		Addr:    c.Server.HTTP.Addr,
		Timeout: c.Server.HTTP.Timeout,
	}
}

// provideGRPCConfig converts main Config to server.GRPCConfig
func provideGRPCConfig(c *Config) *server.GRPCConfig {
	return &server.GRPCConfig{
		Network: c.Server.GRPC.Network,
		Addr:    c.Server.GRPC.Addr,
		Timeout: c.Server.GRPC.Timeout,
	}
}
