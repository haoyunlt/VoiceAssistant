// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"voicehelper/cmd/identity-service/internal/biz"
	"voicehelper/cmd/identity-service/internal/data"
	"voicehelper/cmd/identity-service/internal/infra/oauth"
	"voicehelper/cmd/identity-service/internal/server"
	"voicehelper/cmd/identity-service/internal/service"
)

import (
	_ "go.uber.org/automaxprocs"
)

// Injectors from wire.go:

// wireApp init kratos application.
func wireApp(config *Config, logger log.Logger) (*kratos.App, func(), error) {
	grpcConfig := ProvideGRPCConfig(config)
	dataConfig := ProvideDataConfig(config)
	db, err := data.NewDB(dataConfig, logger)
	if err != nil {
		return nil, nil, err
	}
	dataData, cleanup, err := data.NewData(db, logger)
	if err != nil {
		return nil, nil, err
	}
	userRepository := data.NewUserRepo(dataData, logger)
	tenantRepository := data.NewTenantRepo(dataData, logger)
	userUsecase := biz.NewUserUsecase(userRepository, tenantRepository, logger)
	client := NewRedisClient(config)
	tokenBlacklistService := data.NewTokenBlacklistService(client, logger)
	auditLogRepository := data.NewAuditLogRepository(db)
	auditLogService := biz.NewAuditLogService(auditLogRepository, logger)
	authConfig := ProvideAuthConfig(config)
	authUsecase := biz.NewAuthUsecase(userRepository, tenantRepository, tokenBlacklistService, auditLogService, authConfig, logger)
	tenantUsecase := biz.NewTenantUsecase(tenantRepository, logger)
	oAuthRepository := data.NewOAuthRepo(db)
	wechatClient := ProvideWechatClient(config)
	githubClient := ProvideGithubClient(config)
	googleClient := ProvideGoogleClient(config)
	oAuthUsecase := biz.NewOAuthUsecase(userRepository, oAuthRepository, tenantRepository, authUsecase, wechatClient, githubClient, googleClient)
	identityService := service.NewIdentityService(userUsecase, authUsecase, tenantUsecase, oAuthUsecase, logger)
	grpcServer := server.NewGRPCServer(grpcConfig, identityService, logger)
	httpConfig := ProvideHTTPConfig(config)
	httpServer := server.NewHTTPServer(httpConfig, identityService, logger)
	app := newApp(logger, grpcServer, httpServer)
	return app, func() {
		cleanup()
	}, nil
}

// wire.go:

// ProvideJWTSecret provides JWT secret from config
func ProvideJWTSecret(cfg *Config) string {
	return cfg.Auth.JWTSecret
}

// ProvideAuthConfig provides auth config
func ProvideAuthConfig(cfg *Config) *biz.AuthConfig {
	return &biz.AuthConfig{
		JWTSecret:          cfg.Auth.JWTSecret,
		AccessTokenExpiry:  cfg.Auth.AccessTokenExpiry,
		RefreshTokenExpiry: cfg.Auth.RefreshTokenExpiry,
	}
}

// ProvideHTTPConfig provides HTTP server config
func ProvideHTTPConfig(cfg *Config) *server.HTTPConfig {
	return &server.HTTPConfig{
		Network: cfg.Server.HTTP.Network,
		Addr:    cfg.Server.HTTP.Addr,
		Timeout: cfg.Server.HTTP.Timeout,
	}
}

// ProvideGRPCConfig provides gRPC server config
func ProvideGRPCConfig(cfg *Config) *server.GRPCConfig {
	return &server.GRPCConfig{
		Network: cfg.Server.GRPC.Network,
		Addr:    cfg.Server.GRPC.Addr,
		Timeout: cfg.Server.GRPC.Timeout,
	}
}

// ProvideWechatClient provides Wechat OAuth client
func ProvideWechatClient(cfg *Config) *biz.WechatClient {
	client := oauth.NewWechatClient(cfg.Auth.OAuth.Wechat.AppID, cfg.Auth.OAuth.Wechat.AppSecret)
	return &biz.WechatClient{OAuthClient: client}
}

// ProvideGithubClient provides GitHub OAuth client
func ProvideGithubClient(cfg *Config) *biz.GithubClient {
	client := oauth.NewGitHubClient(cfg.Auth.OAuth.Github.ClientID, cfg.Auth.OAuth.Github.ClientSecret)
	return &biz.GithubClient{OAuthClient: client}
}

// ProvideGoogleClient provides Google OAuth client
func ProvideGoogleClient(cfg *Config) *biz.GoogleClient {
	client := oauth.NewGoogleClient(
		cfg.Auth.OAuth.Google.ClientID,
		cfg.Auth.OAuth.Google.ClientSecret,
		cfg.Auth.OAuth.Google.RedirectURI,
	)
	return &biz.GoogleClient{OAuthClient: client}
}
